#+Title: Clojure
#+Author: lvh
#+Email: _@lvh.io

#+OPTIONS: toc:nil reveal_rolling_links:nil num:nil reveal_history:true
#+REVEAL_TRANS: linear
#+REVEAL_THEME: lvh

* Introduction

** Who am I?

   #+ATTR_HTML: :style width:80%
   [[./media/lvh.svg]]

   #+BEGIN_NOTES
   * Software engineer (distributed systems, infosec)
   #+END_NOTES

** KUL

   [[./media/kul.gif]]

** Rackspace

   #+ATTR_HTML: :style width:90%
   [[./media/rackspace.svg]]

** Python

   #+ATTR_HTML: :style border:none
   [[./media/python.svg]]

   #+BEGIN_NOTES
   Fellow of the Python Software Foundation
   #+END_NOTES

** More importantly: Clojure!

   #+ATTR_HTML: :style border:none
   [[./media/clojure.png]]

** Who are /you/?

   * Experience with FP? Lisps? Clojure?

** What's Clojure?

   ~(apply modern-lisp @jvm)~

   #+BEGIN_NOTES
   Official JS target, various experimental targets
   #+END_NOTES

** What's so nice about it?

   Lots of reasons:

   * ...
   * Immutability & functional programming
   * JVM, but also JS back-ends
   * "Just /do/ it already" (my favorite)

** Just do it already

   (Partial) static typing

   * Python: talking about it forever
     * Annotation syntax is enough, right?
     * Finally going to make it in 3.whatever
   * Clojure: ~core.typed~

** Just do it already

   Software transactional memory

   * Python: 8 working prototypes
     * ~2x slowdown from regular Python
     * Some of the smartest people on it
     * Difficult because Python is hard to optimize
   * Clojure: STM since 1.0

** Just do it already

   Asynchronous programming

   * Python: asyncio
     * (caveat: I am the original author of async-pep)
     * Yay! Yet another event loop framework!


** Just do it already

   Logic programming

   * Python: bunch of weekend hacks
   * Clojure: popular library

** Ball of mud

   Lisp is a ball of mud

   $LANG is a shiny diamond

* Big ideas

** Immutability by default

   * Default types are immutable
   * You can alway import ~ArrayList~
   * unfortunately also ~Date~ :-(

** Functional programming

   "85% functional"

** Java interoperability

** Decomplection

*** Complex

    #+ATTR_REVEAL: :frag roll-in
    * Does many things
    * Related to, but ≠ hard!

*** Simple

    #+ATTR_REVEAL: :frag roll-in
    * Does one thing
    * Related to, but ≠ easy!

* The value of values

** Values /are/ immutable!

   #+BEGIN_NOTES
   Not just in Clojure; *semantically*, mutable values are lies
   #+END_NOTES

** "No-one can cross the same river twice"

** "Single" values

   #+ATTR_REVEAL: :frag roll-in
   * Java: ~BigInt~, ~BigDecimal~...
   * Python: ~int~, ~float~...
   * Counterexample: ~java.util.Date~

** "Compound" values

   E.g. collections

   * Java: ArrayList, Hash(Set|Map)
   * Python: list, set, map...
   * Counterexample: ~tuple~

   #+BEGIN_NOTES
   For some reason we don't accept this for compound values
   #+END_NOTES

* Transducers
** Fairly new feature

   (1.7, beta)

** Only bad part is the name

   * What's a transducer?
     * It's a reducing function transformer!
   * What's a reducing function?
     * It's a function you'd pass to reduce!
   * Gee, thanks!

** Monads

   Just monoids in the category of endofunctors!

   #+BEGIN_NOTES
   My spell checker is not convinced these are words
   #+END_NOTES

** ~map~

   ~(map f coll)~

   ~[(f (coll 0)) (f (coll 1)) ...]~

   ~(map inc [1 2 3]) ;; => (2 3 4)~

** ~reduce~

   ~(defn sum [coll] (reduce + coll))~

** Big idea

   * Extract the /essence/ of map, reduce...
   * Specifically, remove collections

** Processes

   * Succession of steps
   * Each step takes an input
   * Example: building a collection
   * Generally: seeded left reduce

** Example with map

   ~(map f)~

   * Compare ~(map f coll)~

** Big example

   +Stole+ Borrowed from Rich Hickey at Strange Loop

* Concurrency
** STM

   Transactions (ACI, not D)

   #+BEGIN_NOTES
   Transactions: atomicity, consistency, isolation (not durability)
   Since Clojure 1.0
   #+END_NOTES

** STM example

** ~@Raw~

   #+BEGIN_NOTES
   Not complaining about Steegmans or his class
   He's a great guy, hates giving that class in Java as much as we hated getting it in Java
   But @Raw makes me sad
   #+END_NOTES

** Why not locks?

   #+ATTR_HTML: :style width:90%
   [[./media/whynotzoidberg.jpg]]

*** Not usable

    * Hard to reason about
    * Annoying to use

*** Example

*** "Just separate R and W locks!"

    Number of failure modes just doubled too

*** Failure mode

    #+ATTR_REVEAL: :frag roll-in
    * ~Segmentation fault~
    * Data corruption
    * Silent data corruption

* Macrology
** Code ≡ data

   Many basic "language features" are macros:

   ~defn~, ~and~, ~cond~...

   (Just like Racket)

** Domain specific languages

   * Default Lisper behavior

* Polymorphism
** Protocols
** Multimethods

** ~x.m(a, b, c)~

   Which ~m~?

** ~m~ depends on type of ~x~

   * Single dispatch
   * Java, C++, C#...

   #+BEGIN_NOTES
   C# 4.0 apparently supports multimethods
   #+END_NOTES

** Python: bit more complicated

   Not just type of ~x~:

   * Override ~x.m~ on the instance
   * ~__getattr(ibute)__~ hacks

   ~x~ still picks the ~m~!

** "Sending a message"

   (Smalltalk parlance)

   ~x~ ← ~m(a, b, c)~

** No interesting differences

   * Logic is fixed
   * Always up to ~x~

** Single dispatch not always enough

** Multimethods

   Routing logic: ~f(x)~

* ~core.logic~

** The Reasoned Schemer

   [[./media/reasonedschemer.jpg]]

* Conclusion

** A modern, pragmatic Lisp

** Don't learn Clojure!

   Going back is painful ;-)

* Questions?
** Suggested rants

   * Type systems (Scala)
