#+Title: Clojure
#+Author: lvh
#+Email: _@lvh.io

#+OPTIONS: toc:nil reveal_rolling_links:nil num:nil reveal_history:true
#+REVEAL_TRANS: linear
#+REVEAL_THEME: lvh

* Introduction

** Who am I?

   #+ATTR_HTML: :style width:80%
   [[./media/lvh.svg]]

   #+BEGIN_NOTES
   * Software engineer (distributed systems, infosec)
   #+END_NOTES

** KUL

   [[./media/KUL.gif]]

** Rackspace

   #+ATTR_HTML: :style width:90%
   [[./media/Rackspace.svg]]

** Python

   #+ATTR_HTML: :style border:none
   [[./media/Python.svg]]

   #+BEGIN_NOTES
   Fellow of the Python Software Foundation
   Staff member of PyCon US
   #+END_NOTES

** More importantly: Clojure!

   #+ATTR_HTML: :style border:none
   [[./media/Clojure.png]]

** Who are /you/?

   * Functional programming?
     * HOF? ~map~, ~filter~, ~reduce~?
   * Lisps?
   * Clojure?

* Hello, Clojure!
** What's Clojure?

   ~(apply modern-lisp @jvm)~

   #+BEGIN_NOTES
   Official JS target, semi-mature CLR target, various experimental targets
   #+END_NOTES

** Homoiconic syntax

   ~(f a b c)~

   just a different spelling for:

   ~f(a, b, c)~

** A lisp? Really?

   #+ATTR_HTML: :style width:100%
   [[./media/JohnMcCarthy.jpg]]

   #+BEGIN_NOTES
   Originally written for AI
   John McCarthy 1957
   Interpreters, high-level metaprogramming, garbage collection, dynamic programming, functional programming, programming with recursive functions...
   #+END_NOTES

** What's so nice about it?

   Lots of reasons:

   #+ATTR_REVEAL: :frag roll-in
   * Immutability & functional programming
   * JVM, but also JS back-ends
   * Generally applicable
   * "Just /do/ it already" (my favorite)
   * ...

** Just do it already

   (Partial) static typing

   #+ATTR_REVEAL: :frag roll-in
   * Python: talking about it forever
     #+ATTR_REVEAL: :frag roll-in
     * Annotation syntax is enough, right?
     * Finally going to make it in 3.whatever
   * Clojure: ~core.typed~

** Just do it already

   Software transactional memory

   #+ATTR_REVEAL: :frag roll-in
   * Python: 8 working prototypes
     #+ATTR_REVEAL: :frag roll-in
     * ~2x slowdown from regular Python
     * Some of the smartest people on it
     * Difficult because Python is hard to optimize
   * Clojure: STM since 1.0

** Just do it already

   Asynchronous programming

   #+ATTR_REVEAL: :frag roll-in
   * Python: asyncio
     #+ATTR_REVEAL: :frag roll-in
     * (caveat: I am the original author of async-pep)
     * Yay! Yet another event loop framework!
   * Clojure: core.async
     #+ATTR_REVEAL: :frag roll-in
     * Supports both threads & IOC
     * Goroutines? Library, not language feature

** Just do it already

   Logic programming

   #+ATTR_REVEAL: :frag roll-in
   * Python: bunch of weekend hacks
   * Clojure: popular library

** Not about Python

   Most other languages are the same or worse

** Ball of mud

   Lisp is a ball of mud

   $LANG is a shiny diamond

   #+BEGIN_NOTES
   Usually not considered a compliment
   But hopefully I've piqued your interest
   #+END_NOTES

* Big ideas

** Immutability by default

   * Default types are immutable
   * You can alway import ~ArrayList~
   * ... unfortunately also ~Date~ :-(

** Functional programming

   "85% functional"

** Java interoperability

** Decomplection

*** Complex

    #+ATTR_REVEAL: :frag roll-in
    * Does many things
    * Related to, but ≠ hard!

*** Simple

    #+ATTR_REVEAL: :frag roll-in
    * Does one thing
    * Related to, but ≠ easy!

* The value of values

** Values /are/ immutable!

   #+BEGIN_NOTES
   Not just in Clojure; *semantically*, mutable values are lies
   #+END_NOTES

** "Single" values

   #+ATTR_REVEAL: :frag roll-in
   * Java: ~BigInt~, ~BigDecimal~...
   * Python: ~int~, ~float~...
   * Counterexample: ~java.util.Date~

** We've made a terrible mistake!

   12 Jan 1991, 18 Mar 2002

   How many dates?

   #+ATTR_REVEAL: :frag roll-in
   * Two!
   * In Java?
     * Take a ~Date~, change day, month, year
     * Same ~Date~, different date!
     * Why do we accept this?

** Maybe I'm overreacting

   #+ATTR_REVEAL: :frag roll-in
   * Most people agree ~Date~ was a mistake
     * Bloch has apologized for it profusely
   * Most people agree immutable types are good
     * Numerics, strings...
   * ... but mutability is still the default!
     * ~someObject.setWhatever~

** "Compound" values

   E.g. collections

   #+ATTR_REVEAL: :frag roll-in
   * Java: ArrayList, Hash(Set|Map)
   * Python: list, set, dict...
   * Counterexample: tuple

   #+BEGIN_NOTES
   For some reason we don't accept this for compound values
   #+END_NOTES

** We have made a terrible mistake!

   {3, 5}, {3, 5, 7}

   How many sets?

   #+ATTR_REVEAL: :frag roll-in
   * Two!
   * In Java? (and Python, and...)
     * Take a ~HashSet~, add/remove some elements
     * Same ~Set~, different set!
     * Why do we accept this?

** Why are we here?

   Imperative programming!

   * No concept of /time/
   * Everything happens "right now"

** "Can't cross the same river twice"

   (Heraclitus, ~500 BC)

** Value, identity, state

   [[./media/ValueIdentityState.svg]]

** Recap

   * Things don't change in place
   * The future is a function of the past
     * The future does not /change/ the past
   * Concurrency makes everything worse


* Persistent data structures
** What are they?

   #+ATTR_REVEAL: :frag roll-in
   * Class of immutable data structures
   * ~(f x)~ gives you /new/ data structure
   * Not about /persisting/ to a database

** Performance?

   #+ATTR_REVEAL: :frag roll-in
   * Typically not an issue
     * Modern implementations are very efficient
     * JVM is an impressive piece of engineering
   * There are always options:
     * ~transient~, ~persistent!~
     * import classic data structures

** Performance is often /better/

   #+ATTR_REVEAL: :frag roll-in
   * E.g. pointer equality checks
     * Example: Om beating React.js
   * Get data sharing for free
     * No defensive copying, cloning, locks...
   * Conclusion
     * Maybe some operations are slow...
     * Entire program can still be faster!

** New possibilities

   Keeping old versions around is cheap!

  * Easy "undo", "time travel"
  * Speculative evaluation

** How does it actually work?

   Bit-partitioned hash tries

** Bit partitioning

   [[./media/BitPartition.svg]]

** Hash trie

   #+ATTR_HTML: :style width:40%;display:block;margin-left:auto;margin-right:auto
   [[./media/BitPartitionPart.svg]]

   #+ATTR_HTML: :style width:50%
   [[./media/HashTrie.svg]]

** Path copying

   #+ATTR_HTML: :style width:50%
   [[./media/HashTrieWithAssoc.svg]]

** How deep does it go?

   | Depth | Nodes |
   |     0 | 32    |
   |     1 | 1024  |
   |     2 | ~32k  |
   |     3 | ~1M   |
   |     4 | ~32M  |

** Garbage-efficient

   #+ATTR_HTML: :style width:50%
   [[./media/HashTrieGarbage.svg]]

* Reference types & concurrency
** Conventional OOP vs Clojure

   |                | Conventional  | Clojure            |
   |----------------+---------------+--------------------|
   | /              | <             | <                  |
   | *References*   | Direct        | Indirect           |
   | *Objects*      | Mutable       | Immutable          |
   | *Concurrency?* | Lock-and-pray | Ref type semantics |

** Conventional OOP model

   [[./media/RefTypes/Object.svg]]

   Encapsulation doesn't fix this!

** Clojure model

   [[./media/RefTypes/RefAndValue.svg]]

   Indirect reference to immutable value

** Updating

   [[./media/RefTypes/UpdatingRefAndValue.svg]]

   Doesn't affect readers; not affected by readers

** Clojure reference types

   |                | <c> | <c>   | <c>  | <c>      | <c>    |
   |                | ref | agent | atom | volatile | (vars) |
   |----------------+-----+-------+------+----------+--------|
   | /              | <   | <     | <    | <        | <      |
   | *Shared?*      | ✓   | ✓     | ✓    | ✗        | ✗      |
   | *Synchronous?* | ✓   | ✗     | ✓    | ✓        | ✓      |
   | *Coordinated?* | ✓   | ✗     | ✗    | ✗        | ✗      |

** Consistent interface

   * ~(transition-fn ref func [& args])~
   * ~new-state: (func current-state &args)~
   * Get current value: ~@ref~
   * No user locking; no deadlocks

** Ref types provide time semantics

   [[./media/ValueIdentityState.svg]]

** Consistency models

   Deep similarity!

   * Describe how concurrent ops can interact
   * E.g. linearizability, serailizability, RYW, MR, MW...
   * Gives you "time" (not wallclock time)

** Example: atoms

   * ~(atom init-val)~
   * ~(swap! some-atom f & args)~ to modify
     * ~compare-and-set!~ too (bit more low level)
   * ~reset!~ to rudely modify

** Example: atoms

   #+BEGIN_SRC clojure
     (def n (atom 1))

     (swap! n inc)
     ;; => 2

     (swap! n * 10)
     ;; => 20

   #+END_SRC

** Transitions could be ~swap!~

   [[./media/ValueIdentityState.svg]]

* STM

** What is STM?

   #+ATTR_REVEAL: :frag roll-in
   * Software transactional memory
   * Concurrency model
   * Transactions (ACI, not D)
   * Backed by MVCC

   #+BEGIN_NOTES
   Transactions: atomicity, consistency, isolation (not durability)
   Since Clojure 1.0
   #+END_NOTES

** What makes STM special?

   * In Clojure (vs. other ref types):
     * Coordination between refs
   * In general (vs. other concurrency models):
     * Alternative to manual locking

** Clojure API

   * ~ref~ reference type
   * ~dosync~ to make transactions
   * ~alter~ and ~commute~ to modify
     * (~ref-set~ to rudely modify)
   * ~ensure~ to check the current value

** Get the current value:

   #+BEGIN_SRC clojure
     (def n (ref "xyzzy"))

     @n
     ;; => "xyzzy"

     (dosync
      (prn @n))
     ;; xyzzy

   #+END_SRC

** Modify inside transactions

   #+BEGIN_SRC clojure
     (def n (ref 0))

     (alter n inc)
     ;; IllegalStateException
     ;; No transaction running ...
     @n
     ;; => 0

     (dosync (alter n inc))
     @n
     ;; => 1
   #+END_SRC

** STM example

** ~@Raw~

   #+BEGIN_NOTES
   Not complaining about Steegmans or his class
   He's a great guy, hates giving that class in Java as much as we hated getting it in Java
   But @Raw makes me sad
   #+END_NOTES

** Need a synchronization primitive?

   #+ATTR_HTML: :style width:90%
   [[./media/whynotzoidberg.png]]

** Locks are /incredibly/ hard to use

   #+ATTR_REVEAL: :frag roll-in
   * Very tricky to reason about
     #+ATTR_REVEAL: :frag roll-in
     * Deadlock free?
     * Livelock free?
     * Are you /sure/?
   * Some patterns are easy, but inefficient
     * Example: GIL, BKL
   * Requires extensive error handling
     * Yay, orphaned locks!
   * Worst part: often /looks/ like it's working
     * ... even when the program is totally incorrect

** Failure modes

    #+ATTR_REVEAL: :frag roll-in
    * ~Segmentation fault~
    * Data corruption
    * Silent data corruption

** Comparison

    Manual memory management

    versus

    GC and lifetime analysis

* Transducers
** Fairly new feature

   (1.7, beta)

** Only bad part is the name

   #+ATTR_REVEAL: :frag roll-in
   * What's a transducer?
     * It's a reducing function transformer!
   * What's a reducing function?
     * It's a function you'd pass to reduce!
   * Gee, thanks!

** Monads

   Just monoids in the category of endofunctors!

   #+BEGIN_NOTES
   My spell checker is not convinced these are words
   #+END_NOTES

** ~map~

   ~(map f coll)~

   (~(f x)~ for all ~x~ in ~coll~)

   ~(map inc [1 2 3]) ;; => (2 3 4)~

** ~filter~

   ~(filter f coll)~

   (all of the ~x~ in ~coll~, if ~(f x)~)

   ~(filter even? [1 2 3]) ;; => (2)~

** ~reduce~

   ~(defn sum [coll] (reduce + coll))~

** Problem!

   We kept implementing ~map~, ~reduce~, etc.

   * Collections (the ones we just saw)
   * Streams
   * Observables
   * Channels (core.async)

** Big idea

   * Extract the /essence/ of map, reduce...
   * Specifically, remove collections
   * Turn them into /process transformations/
   * Very "functional"

** Processes

   * Succession of steps
   * Each step takes an input
   * Example: building a collection
   * Generally: seeded left reduce

** Example with map

   ~(map f)~

     vs.

   ~(map f coll)~

   ~(partial map f)~

** Example use case

   http://blog.eikeland.se/

   [[./media/EggTransducer/Setup.jpg]]

** Probe + heater + egg + Arduino

   [[./media/EggTransducer/Heater.jpg]]

** Results: delicious!

   [[./media/EggTransducer/Results.jpg]]

** Big example

   +Stole+ Borrowed from Rich Hickey at Strange Loop

   TODO: actually steal

* Macrology
** Code ≡ data

   Many basic "language features" are macros:

   ~defn~, ~and~, ~cond~...

   (Just like Racket)

** Domain specific languages

   * Default Lisper behavior

* Polymorphism
** Protocols
** Multimethods

** ~x.m(a, b, c)~

   Which ~m~?

** ~m~ depends on type of ~x~

   * Single dispatch
   * Java, C++, C#...

   #+BEGIN_NOTES
   C# 4.0 apparently supports multimethods
   #+END_NOTES

** Python: bit more complicated

   Not just type of ~x~, but the value of ~x.m~

   * Override ~x.m~ on the instance
   * ~__getattr(ibute)__~ hacks

   ~x~ still picks the ~m~!

** "Sending a message"

   (Smalltalk parlance)

   ~x~ ← ~m(a, b, c)~

** No interesting differences

   * Logic is fixed
   * Always up to ~x~

** We can do better!

** Multimethods

   Routing logic: ~f(x)~

** Example

   TODO: show examples in icecap

* ~core.logic~

** The Reasoned Schemer

   [[./media/ReasonedSchemer.jpg]]

* Conclusion
** A modern, pragmatic Lisp

** Don't learn Clojure!

   Going back is painful ;-)

* Thank you!
* Questions?
** Suggested rants

   Bad type systems

   * Scala: ~def map[B, That](f: A => B)(implicit bf:
     CanBuildFrom[Repr, B, That]): That~
   * Go: ~interface{}~
